http://khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf
    OpenGL 快速参考卡片：包括 着色语言GLSL

OpenGL 只能绘制 点 线 和 三角形

顶点
    顶点的坐标： 与世界坐标 方向一致,  原点的位置？

三角形
    在顶点数组中，需要以逆时针顺序定义三角形的 三个顶点； 称为：卷曲顺序

顶点着色器   vertex shader
    生成每个顶点的最终位置，针对每个顶点，它都会执行一次；
    一旦最终位置确定了，OpenGL就可以把这些可见顶点的集合组装成点、线、三角形
片断着色器   fragment shader
    为组成点、线、三角形的每个片断生成最终的颜色，针对每个片断，它都会执行一次；
    一个片断通常是一个小的、单一颜色的长方形区域，类似计算机屏幕上的一个像素;
        然而一个超大分辨率的设置可能需要使用较大的片断，即一个片断对就几个像素
    每个片断(像素)都有四个分量：红色、绿色、蓝色、alpha
        Android颜色转OpenGL颜色： Color.red(Color.parseColor("#abc777")) / 255f;
一旦最后的颜色生成了，OpenGL会把它们写到一块帧缓冲区(frame buffer)中，然后Android将其显示到屏幕上
使用GLSL定义着色器，见res/raw/*.glsl

显示流程：
    读取顶点数据 -——> 执行顶点着色器 -——> 组装图元 -——> 光栅化图元(RGBA)
    -——> 执行片断着色器 -——> 写入帧缓冲区 -——> 显示在屏幕上

OpenGL 将一个顶点和片断着色器链接在一起变成单个对象。它们是一起工作的。

正交投影：使用正交投影，不管多远或多近，所有的物体看上去大小总是相同的。
            比如，从空中俯瞰火车轨道；从侧角观看火车轨道(等轴测投影，特殊的正交投影)
        使用正交投影矩阵，将一个封闭立方体映射到屏幕上，矩阵会改变立方体的大小，
            以使我们在屏幕上看到或多或少的场景；我们也能改变立方体的形状弥补屏幕宽高比的影响

OpenGL-矩阵
    一个位置向量，通常是一个四元素的列向量：[x y z w]T
    OpenGL中的矩阵，则是一个4x4的矩阵
    单位矩阵：从左上到右下 对角线上的 元素值为1. 任何向量 乘以 单位矩阵，都等于原向量
    平移矩阵：平移的距离就写在 第4列上，用这平移矩阵 乘以原向量，得出最终的位置向量
  android.opengl.Matrix
    正交投影函数: public static void orthoM(float[] m, int mOffset,
                    float left, float right, float bottom, float top,
                    float near, float far);
        m 16个元素的数组，用于存储矩阵;
        mOffset 矩阵起始的偏移；
        left        x轴的最小范围
        right       x轴的最大范围
        bottom      y轴的最小范围
        top         y轴的最大范围
        near        z轴的最小范围  近
        far         z轴的最大范围  远
       改变左右上下的值：都缩小时，图形显示的更大了；反之，显示更小；
       正交投影：能将横竖屏 看到的物体 是  同样大小的
    左手、右手坐标系统：
        OpenGL2.0 后用的是左手的； 早期是右手的；
        无论左手、右手：x正向右；y正向右；而左手时，z正向右上；右手时z正向左下
        由于这个历史原因：z值的负值增加，才表示距离更远
        右手笛卡尔坐标系统。这么描述吧：高抬右手，大拇指向右、食指向上、中指弯90°。
            大拇指方向为X正轴方向（从左到右），食指方向为Y正轴方向（从下到上），中指呢就是Z正轴方向（从里到外）。

OpenGL 坐标系
    1. 描述顶点时，屏幕左边(x)和下边(y)都是 -1， 右边(x)和上边(y)都是 1; 对于z轴也是一样； 称为 归一化 坐标
         归一化坐标独立于屏幕坐标。其假定坐标空间是一个正方形。而实际视口viewport可能不是一个正方形，
         就会造成，图像在一个方向上被拉伸，在另一个方向上被拉扁。
       适应宽高比：按屏幕尺寸的比例来调整 坐标较大的范围
            例：屏幕宽720，高1280；竖屏时，宽度还是[-1,1]，高度则为[-1280f/720f,1280f/720f]；
                横屏时，高度是[-1,1]，宽度[-1280f/720f,1280f/720f]
进入三维：
    裁剪空间：当着色器把一个值写到gl_position中时，OpenGL期望这个位置在裁剪空间内；
        在任何给定位置中，x、y、z分量的值都需要在-w到w之间。 一般我们不指定w时，默认就是1，所以x、y、z默认在[-1,1]之间。
    透视除法：为了屏幕上创建三维的幻象，OpenGL会把每个gl_Position的x、y、z分量的值除以w分量值。
            当w用来表示距离的时候，就使得较远处(w越大)的物体被移动到距离渲染区域中心更近的地方。
            如，假设一个物体，它有两个顶点，且都在三维空间中的同一个位置，它们有着同样的xyz分量，但是w分量不同。
                (1,1,1,1)  (1,1,1,2) => (1,1,1) (0.5,0.5,0.5)
                有较大w值的坐标点 就离(0,0,0)更近了。 再如 (-1,-1,-1,4)=>(-0.25,-0.25,-0.25)
        利用w分量产生的三维效果，是线性的。并且是沿着直线完成的。现实中的更加复杂
    同质化坐标：因透视除法，裁剪空间中的坐标，就称为同质化坐标。
    视口变换：OpenGL将归一化坐标的xyz分量映射到屏幕上的一个区域内，这个区域就是视口。这些被映射的坐标为窗口坐标。
        当映射时，会把(-1,-1,-1)到(1,1,1)的范围映射到屏幕上的那个视口区域。这个范围外的坐标会被裁剪掉。
    视椎体：简单说，它是一个立方体，其远端比近端大，两端的大小差别越大，观察的范围越宽，能看到的就越多。
        一个视椎体有一个焦点。较大端向较小端扩展出来的那些直线，一直向前通过较小端直到相交的点。
        当用透视投影观察时，就像将头放在了焦点处。
        焦点和视椎体的小端的距离称为焦距，它影响小端和大端的比例，及其对应的视野。
    定义透视投影：透视投影矩阵和透视除法一起发挥作用。
        如果一个物体向屏幕中心移动，当它离我们越远时，它越小，因此投影矩阵的最重要任务就是产生正确的w值，从而透视除法才会正确。
        实现方法之一就是利用z分量，把它作为物体与焦点的距离，且把这个距离映射到w。这个值越大，w越大，物体显示越小。
    对宽高比和视野进行调整：随着视野变小，焦距变长，映射到归一化坐标中的xy值就越小。这会使得视椎体变窄
    函数：Matrix.perspectiveM() 透视投影矩阵
        Matrix.perspectiveM(projectionMatrix, 0, 45, (float) width / height, 1, 0);
            按45度视角创建透视投影。这个视椎体从z值为-1到-10 (注意传递的参数不能为负值)
    利用模型矩阵移动物体
        若不指定z的位置，默认z值为0. 如上例z是从-1到-10，这时就需要 利用模型矩阵进行移动
        float[] modelMatrix = new float[16];
        //设为 单位矩阵
        Matrix.setIdentityM(modelMatrix, 0);
        //z轴 负方向 平移 2个单位
        Matrix.translateM(modelMatrix, 0, 0, 0, -2f);
       用投影矩阵乘以模型矩阵，即最终的变换矩阵:
         float[] temp = new float[16];
         Matrix.multiplyMM(temp, 0, projectionMatrix, 0, modelMatrix, 0);
         System.arraycopy(temp, 0, projectionMatrix, 0, temp.length);
    旋转：
        旋转的方向：围绕哪个轴进行旋转。
            绕x轴：即绕左右端，上下旋转； 绕y轴：即绕上下端，左右旋转； 绕z轴：会在一个圆圈内旋转
        旋转矩阵：
            绕x轴，以单位矩阵中，第二列：<0, cos(a), sin(a), 0> ， 第三列：<0, -sin(a), cos(a), 0>
            绕y轴，以单位矩阵中，第一列：<0, cos(a), -sin(a), 0> ，第三列：<0,  sin(a), cos(a), 0>
            绕z轴，以单位矩阵中，第一列：<0, cos(a), sin(a), 0> ， 第二列：<0, -sin(a), cos(a), 0>
        使用旋转矩阵函数：
纹理 texture
    简单来说，纹理就是一个图像或照片，它们可以被载入到 OPENGL 中
    二维的纹理坐标：(0~1) ，从左各右，从下向上； 横向维度记作 S，纵向记作 T，即ST 纹理坐标，有时也被称为 UV 纹理坐标。
    纹理没有内在的方向性，但屏幕有：x 向右为正，y 向下为正。
    纹理不必是正方形，但每个维度必须是2的幂 POT。POT纹理可以适用于各种情况。
    纹理的尺寸有一个最大值，它根据不同的实现而变化，但通常比较大，如2048x2048。
纹理过滤
    当纹理大小被扩大或缩小时，需要使用纹理过滤明确的说明会发生什么。
    比如，当将几个纹理挤进一个片断时，会缩小；将一个纹理扩展到多个片断时，会放大。
  最近邻过滤
    为每个片断选择最近的纹理元素。
    当放大纹理时，它的锯齿效果相当明显，每个纹理单元都清楚的显示为一个小方块。
    当缩小纹理时，因没有足够的片断来绘制所有的纹理单元，许多细节会丢失。
  双线性插值过滤
    双线性插值平滑像素之间的过渡。
    使用4个邻接的纹理元素，运用双线性插值算法做插值。
    放大后，还是会有锯齿，但不会太明显。
    缩小后，也会丢失一些细节。
  MIP 贴图  mipmapping
    在基于双线索过滤，再使用 MIP 技术，能克服上述缺陷。生成一组优化过的不同大小的纹理。
    使用所有的纹理元素，生成多个级别的纹理。
    在渲染时，会根据每个片断的纹理元素数量，选择合适的级别。
    会占用更多的内存。渲染速度会更快，因为较小级别的纹理在 GPU的纹理缓存中占用较小的空间。
  三线性过滤
    在渲染时，不同级别的 MIP贴图切换，有时能看到明显的跳跃或线条。这时，可以考虑使用三线性过滤。
    三线性过滤，即在两个邻近的 MIP贴图之间也要插值计算。这样每个片断共需要8个纹理元素插值，
    从而能得到一个更平滑的图像。

构建简单物体
    三角形：GL_TRIANGLE
    三角形扇：先定义扇形的中心点，再定义其它 n 个顶点，会连成多个三角形。 GL_TRIANGLE_FAN
    三角形带：与三角形扇类似。前三个顶点定义了第一个三角形，之后的每个额外顶点，都定义了一个三角形。GL_TRIANGLE_STRIP
  简单的矩阵层次结构
    模形矩阵
       是用来把物体放在世界坐标系中的。如 示例：airehockey5_withimprovedmallets 中，冰球和木槌模型，它们的初始
       的中心点在(0,0,0)。没有模型矩阵，是手动更新每个模型的相关顶点。有了模型矩阵，只需要点与其相乘，从而变换顶点，
       达到平移、旋转、缩放目的
    视图矩阵
       会平等的影响场景中的每一个物体。因其影响所有物体，所以功能上等同于一个相机：来回移动相机，你会从不同的视角看
       到那些物体。物体的变换，交由一个矩阵存储，最后物体再应用该矩阵
    投影矩阵
       帮助创建三维的幻象，通常只有当屏幕变换方位时，它才会变化。
    顶点从原来的位置变换到屏幕
       vertex-model: 这是模型坐标系中的一个顶点。例如被包含在桌子顶点内部的位置。
       vertex-world：世界空间中用模型矩阵定位过的一个顶点
       vertex-eye：这是我们的眼睛或相机相对的一个顶点。我们使用一个视图矩阵让所有的顶点在世界空间中绕着我们当前的
                  观察位置移动。
       vertex-clip: 这是被投影矩阵处理过的一个顶点。下一步就是做透视除法。
       vertex-ndc： 这是归一化设备坐标系中的一个顶点。一旦一个顶点落在这个坐标系中，OPENGL 就会把它映射到视口，
                    你就能在屏幕中看到它了。
                    链条关系：
                        vertex-clip = projectionMatrix * vertex-eye；
                        vertex-clip = projectionMatrix * viewMatrix * vertex-world；
                        vertex-clip = projectionMatrix * viewMatrix * modelMatrix * vertex-model；






